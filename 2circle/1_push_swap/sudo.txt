
def A_to_B(r)
	if r < 3
		적절히 정렬
		return
	스택A 원소 중에서 "적절한" 피봇을 2개 선택한다
	tmp = 스택A의 top # 연산할 대상
	for r개의 원소에 대해서
		if tmp >= 피봇[큰것]
			ra명령으로 뒤로 넘긴다
			ra호출횟수++
		else
			pb명령으로 b로 보낸다
			pb호출횟수++
			if tmp >= 피봇 [작은것]
				rb명령으로 뒤로 넘긴다
				rb호출횟수++
	for ra호출횟수, rb호출횟수
		rrr호출 #[3]과 [2]를 스택 앞으로 가져온다
	A_to_B(ra호출 횟수) #[3]
	B_to_A(rb호출 횟수) #[2]
	B_to_A(pb호출 횟수 - rb 호출 횟수) #[1]

def B_to_A(r)
	if r < 3
		적절히 정렬/pa로 보내기
		return
	스택B 원소 중에서 "적절한" 피봇을 2개 선택한다
	tmp = 스택B의 top # 연산할 대상
	for r개의 원소에 대해서
		if tmp < 피봇[작은것]
			rb명령으로 뒤로 넘긴다
			rb호출횟수++
		else
			pa명령으로 a로 보낸다
			pa호출횟수++
			if tmp < 피봇 [큰것]
				ra명령으로 뒤로 넘긴다
				ra호출횟수++
	A_to_B(pa호출횟수 - ra호출횟수) #[3]
	for ra호출횟수, rb호출횟수
		rrr호출 #[1]과 [2]를 스택 앞으로 가져온다
	A_to_B(ra호출횟수) #[2]
	B_to_A(rb호출횟수) #[1]
```

b_to_a()에 한 번도 안 들어갔을 때만 rrr과 rra를 안 하면 되는 거니까, b_to_a()에 한 번이라도 들어갔는지를 확인하는 변수를 만들었다.
int형 cnt 변수를 선언하고 0으로 초기화했다.
그리고 처음 push_swap()에서 a_to_b()를 호출할 때 &cnt로 넣어줬다.
b_to_a()에서도 주소값을 보내서 다른 함수에서 바뀐 값을 그대로 가지고 다니게 했다.

a_to_b()에서는 cnt의 값을 변경하지 않고, b_to_a()에 들어가면 기장 먼저 cnt 값을 +1 해준다.
이렇게 하면 한 번이라도 b_to_a()에 들어갔으면 cnt는 0이 아닌 값을 가지게 될 것이다.
이제 a_to_b()에서 rrr과 rra를 할 때, cnt 값이 0보다 큰지를 확인해서 0보다 클 때만 rrr과 rra를 해준다. 0보다 크지 않을 때는 rrb만 해준다.


2
1
3. S
3
1
2.  S r s rr
2
3.
1.    R s rr s
1
3
2.   R s rr
3
2
1.   S r s rr s